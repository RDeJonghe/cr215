/* 6:01
Write a function that connects each previous word to the next word by the shared letters. Return the resulting string (removing duplicate characters in the overlap) and the minimum number of shared letters across all pairs of strings.

Examples
join(["oven", "envier", "erase", "serious"]) ➞ ["ovenvieraserious", 2]

join(["move", "over", "very"]) ➞ ["movery", 3]

join(["to", "ops", "psy", "syllable"]) ➞ ["topsyllable", 1]

// "to" and "ops" share "o" (1)
// "ops" and "psy" share "ps" (2)
// "psy" and "syllable" share "sy" (2)
// the minimum overlap is 1

join(["aaa", "bbb", "ccc", "ddd"]) ➞ ["aaabbbcccddd", 0]
Notes
More specifically, look at the overlap between the previous words ending letters and the next word's beginning letters.

INPUT - array of strings
OUTPUT - array, with a string and an integer
REQUIREMENTS
- have to connect previous word with next word by shared letters
  - connecting by shared letter means that the duplicate overlap chars are combined into one
    - to & ops -> tops
    - ops & psy -> opsy
    - ovenv...
    - er erase -> eras..
    - serious
  -  is just building an output string that overlaps and combines the overlapping sections of the strings int he array -> to one output string
  - "remove duplicate chars in overlap"
- also return the minimum letters of all shared strings across all of them
- track the overlap for each combination that happens
- from all the overlaps find the smallest one 

QUESTIONS
- will the array always consist of strings? - yes (no other types)
- can the array be empty? - yes
- case - do I have to hanlde case? - disregard case treat as equal

EXAMPLES/TEST CASES

DATA STRUCTURES/INTERMEDIATE DATA STRUCTURES
- arrays, strings
- array of overlaps [2, 3, 1, 0...] this would represent the overlaps and could choose the smallest (generated by the algorithm)
- string is combined and altered as it's created in iteration
  - would be to do this with arrays of characters
  [o v e n], [e n v i e r] -> [o v e n i e r]
  [o v e n i e r] , [e r a s e] ->  [o v e n i e r a s e]
- oven envier ->

APPROACHES
1. splititng into arrays of characters - very similar appraoch to number 2, but with the additional steps of splitting and joining chars
2. just dealing with it at the string level. set a result word = to the first word and start iteration at the second word, find the overlap between the two words and reassing the result word to the combination of this. On every iteration this combination happens. Additionally on every iteration the overlap is noted and sent to a reuslts array for overlaps.

ALGORITHM
- handle edge case of empty array if necessary
- if necessary handle edge case of empty strings
- set up a overlap array
- set up a results string equal to the first element
- begin iteration on the second element
  - on each iteration determine the overlap (helper method)
    - arguments: the result string and the current string
  - also combine the string to a result string (helper method)
    - same arguments
  - on each iteration result string is reassigned and dynamically built

SUB PROBLEMS

- combine
  - use the same algorithm to determine the ovelap but not intersted in length
  - instead use thos chars
  - oven en envier 
  - split on the overlap en
    - take the first element and combine with the chars

- find all substrings from the end of the word going forward
  - start iteration from the first char
  - iterate forward
  - and increase the start slice from 0 all the way to the last char
  - end slice stays the same at length


  - determine the overlap
  - given 2 strings, need to really compare the ending of one and the beginning of another 
  - "oven", "envier"
  - find trailing substrings for the result word
  - find leading substrings for the current word
  - find from both arrays all of these that are equal
  - set up a results
    - iterate over all of the substrings for the first arr
    - iterate over the second and send to results any that are strictly equal
  - this will give an array of all the substrings that are equal
  - if emptuy return 0
  - otherwise find the longest and return the length of the longest

  - combine
  - use the same algorithm to determine the ovelap but not intersted in length
  - instead use thos chars
  - oven en envier 
  - split on the overlap en
    - take the first element and combine with the chars
  - overlap is something like this "en"
  - result word which is "oven"

oven
envier
 envier
  envier
'en', 2
'oven'.slice(0, 'oven'.length - 2) + secondWord
ov + envier

Math.min(2, minLengthSoFar)

*/

function combine(resultStr, currentStr) {
  let trailing = trailingSubstrings(resultStr);
  let leading = leadingSubstrings(currentStr);
  let overlapping = [];
  trailing.forEach(trailsubstr => {
    leading.forEach(leadsubstr => {
      if (trailsubstr === leadsubstr) overlapping.push(trailsubstr);
    })
  })
  let sliceIdx = 0;
  if (overlapping[0].length > 0) {
    sliceIdx = overlapping[0].length;
  } 
  return resultStr.slice(0, resultStr.length - sliceIdx) + currentStr;
}

function determineTheOverlap(resultStr, currentStr) {
  let trailing = trailingSubstrings(resultStr);
  let leading = leadingSubstrings(currentStr);
  let overlapping = [];
  trailing.forEach(trailsubstr => {
    leading.forEach(leadsubstr => {
      if (trailsubstr === leadsubstr) overlapping.push(trailsubstr);
    })
  })
  if (overlapping.length === 0) return 0;
  return overlapping[0].length;
}

function trailingSubstrings(str) {
  let results = [];
  let endIdx = str.length;
  for (let startIdx = 0; startIdx < str.length; startIdx += 1) {
    results.push(str.slice(startIdx, endIdx));
  }
  return results;
}

function leadingSubstrings(str) {
  let results = [];
  let startIdx = 0;
  for (let endIdx = 1; endIdx <= str.length; endIdx += 1) {
    results.push(str.slice(startIdx, endIdx));
  }
  return results;
}


function join(arr) {
  let overlaps = [arr[0].length];
  let resultStr = arr[0];
  for (let i = 1; i < arr.length; i += 1) {
    overlaps.push(determineTheOverlap(resultStr, arr[i]));
    resultStr = combine(resultStr, arr[i]);
  }

  console.log(overlaps);
  console.log(resultStr)
}



console.log(join(["oven", "envier", "erase", "serious"]));// ["ovenvieraserious", 2]
console.log(join(["move", "over", "very"]));// ["movery", 3]
// // ALL OVERLAP
console.log(join(["to", "ops", "psy", "syllable"]));// ["topsyllable", 1]
// // NO OVERLAP
// console.log(join(["aaa", "bbb", "ccc", "ddd"]));// ["aaabbbcccddd", 0]

// // EMPTY ARRAY
// console.log(join([])) ;// []
// // ONE STRING GIVEN
// console.log(join(["hello"])); // ['hello', 0]
// // SOME OVERLAP AND SOME DON'T
// console.log(join(["aaa", "bbb", 'bob'])); // ['aaabbbob', 0]
// // empty strings
// console.log(join(['', '', ''])); // ['', 0]
// // case - ignore case
// console.log(join(["Move", "Over", "Very"])); // ["movery", 3]
// // special chars
// console.log(join(["m!@$", "!@$er", "ery"])); // ["m!@$ery", 2]
